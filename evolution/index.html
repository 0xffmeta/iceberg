<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://iceberg.apache.org/evolution/">
    <link rel="shortcut icon" href="../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Table evolution - Apache Iceberg</title>
    <link href="../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/highlight.css">
    <link href="../css/extra.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../js/jquery-3.2.1.min.js"></script>
    <script src="../js/bootstrap-3.3.7.min.js"></script>
    <script src="../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Table Evolution", url: "#_top", children: [
              {title: "Schema evolution", url: "#schema-evolution" },
              {title: "Partition evolution", url: "#partition-evolution" },
              {title: "Sort order evolution", url: "#sort-order-evolution" },
          ]},
        ];

    </script>
    <script src="../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    <!--
 - Licensed to the Apache Software Foundation (ASF) under one or more
 - contributor license agreements.  See the NOTICE file distributed with
 - this work for additional information regarding copyright ownership.
 - The ASF licenses this file to You under the Apache License, Version 2.0
 - (the "License"); you may not use this file except in compliance with
 - the License.  You may obtain a copy of the License at
 -
 -   http://www.apache.org/licenses/LICENSE-2.0
 -
 - Unless required by applicable law or agreed to in writing, software
 - distributed under the License is distributed on an "AS IS" BASIS,
 - WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 - See the License for the specific language governing permissions and
 - limitations under the License.
 -->

<h1 id="table-evolution">Table Evolution<a class="headerlink" href="#table-evolution" title="Permanent link">&para;</a></h1>
<p>Iceberg supports <strong>in-place table evolution</strong>. You can <a href="#schema-evolution">evolve a table schema</a> just like SQL &ndash; even in nested structures &ndash; or <a href="#partition-evolution">change partition layout</a> when data volume changes. Iceberg does not require costly distractions, like rewriting table data or migrating to a new table.</p>
<p>For example, Hive table partitioning cannot change so moving from a daily partition layout to an hourly partition layout requires a new table. And because queries are dependent on partitions, queries must be rewritten for the new table. In some cases, even changes as simple as renaming a column are either not supported, or can cause <a href="#correctness">data correctness</a> problems.</p>
<h2 id="schema-evolution">Schema evolution<a class="headerlink" href="#schema-evolution" title="Permanent link">&para;</a></h2>
<p>Iceberg supports the following schema evolution changes:</p>
<ul>
<li><strong>Add</strong> &ndash; add a new column to the table or to a nested struct</li>
<li><strong>Drop</strong> &ndash; remove an existing column from the table or a nested struct</li>
<li><strong>Rename</strong> &ndash; rename an existing column or field in a nested struct</li>
<li><strong>Update</strong> &ndash; widen the type of a column, struct field, map key, map value, or list element</li>
<li><strong>Reorder</strong> &ndash; change the order of columns or fields in a nested struct</li>
</ul>
<p>Iceberg schema updates are <strong>metadata changes</strong>, so no data files need to be rewritten to perform the update.</p>
<p>Note that map keys do not support adding or dropping struct fields that would change equality.</p>
<h3 id="correctness">Correctness<a class="headerlink" href="#correctness" title="Permanent link">&para;</a></h3>
<p>Iceberg guarantees that <strong>schema evolution changes are independent and free of side-effects</strong>, without rewriting files:</p>
<ol>
<li>Added columns never read existing values from another column.</li>
<li>Dropping a column or field does not change the values in any other column.</li>
<li>Updating a column or field does not change values in any other column.</li>
<li>Changing the order of columns or fields in a struct does not change the values associated with a column or field name.</li>
</ol>
<p>Iceberg uses unique IDs to track each column in a table. When you add a column, it is assigned a new ID so existing data is never used by mistake.</p>
<ul>
<li>Formats that track columns by name can inadvertently un-delete a column if a name is reused, which violates #1.</li>
<li>Formats that track columns by position cannot delete columns without changing the names that are used for each column, which violates #2.</li>
</ul>
<h2 id="partition-evolution">Partition evolution<a class="headerlink" href="#partition-evolution" title="Permanent link">&para;</a></h2>
<p>Iceberg table partitioning can be updated in an existing table because queries do not reference partition values directly.</p>
<p>When you evolve a partition spec, the old data written with an earlier spec remains unchanged. New data is written using the new spec in a new layout. Metadata for each of the partition versions is kept separately. Because of this, when you start writing queries, you get split planning. This is where each partition layout plans files separately using the filter it derives for that specific partition layout. Here&rsquo;s a visual representation of a contrived example: </p>
<p><img alt="Partition evolution diagram" src="../img/partition-spec-evolution.png" />
<em>The data for 2008 is partitioned by month. Starting from 2009 the table is updated so that the data is instead partitioned by day. Both partitioning layouts are able to coexist in the same table.</em></p>
<p>Iceberg uses <a href="../partitioning/">hidden partitioning</a>, so you don&rsquo;t <em>need</em> to write queries for a specific partition layout to be fast. Instead, you can write queries that select the data you need, and Iceberg automatically prunes out files that don&rsquo;t contain matching data.</p>
<p>Partition evolution is a metadata operation and does not eagerly rewrite files.</p>
<p>Iceberg&rsquo;s Java table API provides <code>updateSpec</code> API to update partition spec. 
For example, the following code could be used to update the partition spec to add a new partition field that places <code>id</code> column values into 8 buckets and remove an existing partition field <code>category</code>:</p>
<pre><code class="language-java">Table sampleTable = ...;
sampleTable.updateSpec()
    .addField(bucket(&quot;id&quot;, 8))
    .removeField(&quot;category&quot;)
    .commit();
</code></pre>
<p>Spark supports updating partition spec through its <code>ALTER TABLE</code> SQL statement, see more details in <a href="../spark-ddl/#alter-table-add-partition-field">Spark SQL</a>.</p>
<h2 id="sort-order-evolution">Sort order evolution<a class="headerlink" href="#sort-order-evolution" title="Permanent link">&para;</a></h2>
<p>Similar to partition spec, Iceberg sort order can also be updated in an existing table.
When you evolve a sort order, the old data written with an earlier order remains unchanged.
Engines can always choose to write data in the latest sort order or unsorted when sorting is prohibitively expensive.</p>
<p>Iceberg&rsquo;s Java table API provides <code>replaceSortOrder</code> API to update partition spec. 
For example, the following code could be used to create a new sort order 
with <code>id</code> column sorted in ascending order with nulls last,
and <code>category</code> column sorted in descending order with nulls first:</p>
<pre><code class="language-java">Table sampleTable = ...;
sampleTable.replaceSortOrder()
   .asc(&quot;id&quot;, NullOrder.NULLS_LAST)
   .dec(&quot;category&quot;, NullOrder.NULL_FIRST)
   .commit();
</code></pre>
<p>Spark supports updating sort order through its <code>ALTER TABLE</code> SQL statement, see more details in <a href="../spark-ddl/#alter-table-write-ordered-by">Spark SQL</a>.</p>

  <br>
</div>

<footer class="container-fluid wm-page-content"><p>Copyright 2018-2021 <a href='https://www.apache.org/'>The Apache Software Foundation</a><br />Apache Iceberg, Iceberg, Apache, the Apache feather logo, and the Apache Iceberg project logo are either registered<br />trademarks or trademarks of The Apache Software Foundation in the United States and other countries.</p>
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>