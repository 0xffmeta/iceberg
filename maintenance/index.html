<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://iceberg.apache.org/maintenance/">
    <link rel="shortcut icon" href="../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Maintenance - Apache Iceberg</title>
    <link href="../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/highlight.css">
    <link href="../css/extra.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../js/jquery-3.2.1.min.js"></script>
    <script src="../js/bootstrap-3.3.7.min.js"></script>
    <script src="../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Table Maintenance", url: "#_top", children: [
              {title: "Recommended Maintenance", url: "#recommended-maintenance" },
              {title: "Optional Maintenance", url: "#optional-maintenance" },
          ]},
        ];

    </script>
    <script src="../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    <!--
 - Licensed to the Apache Software Foundation (ASF) under one or more
 - contributor license agreements.  See the NOTICE file distributed with
 - this work for additional information regarding copyright ownership.
 - The ASF licenses this file to You under the Apache License, Version 2.0
 - (the "License"); you may not use this file except in compliance with
 - the License.  You may obtain a copy of the License at
 -
 -   http://www.apache.org/licenses/LICENSE-2.0
 -
 - Unless required by applicable law or agreed to in writing, software
 - distributed under the License is distributed on an "AS IS" BASIS,
 - WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 - See the License for the specific language governing permissions and
 - limitations under the License.
 -->

<h1 id="table-maintenance">Table Maintenance<a class="headerlink" href="#table-maintenance" title="Permanent link">&para;</a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Maintenance operations require the <code>Table</code> instance. Please refer <a href="/java-api-quickstart/#create-a-table">Java API quickstart</a> page to refer how to load an existing table.</p>
</div>
<h2 id="recommended-maintenance">Recommended Maintenance<a class="headerlink" href="#recommended-maintenance" title="Permanent link">&para;</a></h2>
<h3 id="expire-snapshots">Expire Snapshots<a class="headerlink" href="#expire-snapshots" title="Permanent link">&para;</a></h3>
<p>Each write to an Iceberg table creates a new <em>snapshot</em>, or version, of a table. Snapshots can be used for time-travel queries, or the table can be rolled back to any valid snapshot.</p>
<p>Snapshots accumulate until they are expired by the <a href="../javadoc/0.12.0/org/apache/iceberg/Table.html#expireSnapshots--"><code>expireSnapshots</code></a> operation. Regularly expiring snapshots is recommended to delete data files that are no longer needed, and to keep the size of table metadata small.</p>
<p>This example expires snapshots that are older than 1 day:</p>
<pre><code class="language-java">Table table = ...
long tsToExpire = System.currentTimeMillis() - (1000 * 60 * 60 * 24); // 1 day
table.expireSnapshots()
     .expireOlderThan(tsToExpire)
     .commit();
</code></pre>
<p>See the <a href="../javadoc/0.12.0/org/apache/iceberg/ExpireSnapshots.html"><code>ExpireSnapshots</code> Javadoc</a> to see more configuration options.</p>
<p>There is also a Spark action that can run table expiration in parallel for large tables:</p>
<pre><code class="language-java">Actions.forTable(table)
    .expireSnapshots()
    .expireOlderThan(tsToExpire)
    .execute();
</code></pre>
<p>Expiring old snapshots removes them from metadata, so they are no longer available for time travel queries.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Data files are not deleted until they are no longer referenced by a snapshot that may be used for time travel or rollback.
Regularly expiring snapshots deletes unused data files.</p>
</div>
<h3 id="remove-old-metadata-files">Remove old metadata files<a class="headerlink" href="#remove-old-metadata-files" title="Permanent link">&para;</a></h3>
<p>Iceberg keeps track of table metadata using JSON files. Each change to a table produces a new metadata file to provide atomicity.</p>
<p>Old metadata files are kept for history by default. Tables with frequent commits, like those written by streaming jobs, may need to regularly clean metadata files.</p>
<p>To automatically clean metadata files, set <code>write.metadata.delete-after-commit.enabled=true</code> in table properties. This will keep some metadata files (up to <code>write.metadata.previous-versions-max</code>) and will delete the oldest metadata file after each new one is created.</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>write.metadata.delete-after-commit.enabled</code></td>
<td>Whether to delete old metadata files after each table commit</td>
</tr>
<tr>
<td><code>write.metadata.previous-versions-max</code></td>
<td>The number of old metadata files to keep</td>
</tr>
</tbody>
</table>
<p>See <a href="/configuration/#write-properties">table write properties</a> for more details.</p>
<h3 id="remove-orphan-files">Remove orphan files<a class="headerlink" href="#remove-orphan-files" title="Permanent link">&para;</a></h3>
<p>In Spark and other distributed processing engines, task or job failures can leave files that are not referenced by table metadata, and in some cases normal snapshot expiration may not be able to determine a file is no longer needed and delete it.</p>
<p>To clean up these &ldquo;orphan&rdquo; files under a table location, use the <code>removeOrphanFiles</code> action.</p>
<pre><code class="language-java">Table table = ...
Actions.forTable(table)
    .removeOrphanFiles()
    .execute();
</code></pre>
<p>See the <a href="../javadoc/0.12.0/org/apache/iceberg/actions/RemoveOrphanFilesAction.html">RemoveOrphanFilesAction Javadoc</a> to see more configuration options.</p>
<p>This action may take a long time to finish if you have lots of files in data and metadata directories. It is recommended to execute this periodically, but you may not need to execute this often.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is dangerous to remove orphan files with a retention interval shorter than the time expected for any write to complete because it
might corrupt the table if in-progress files are considered orphaned and are deleted. The default interval is 3 days.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Iceberg uses the string representations of paths when determining which files need to be removed. On some file systems,
the path can change over time, but it still represents the same file. For example, if you change authorities for an HDFS cluster, 
none of the old path urls used during creation will match those that appear in a current listing. <em>This will lead to data loss when 
RemoveOrphanFiles is run</em>. Please be sure the entries in your MetadataTables match those listed by the Hadoop
FileSystem API to avoid unintentional deletion. </p>
</div>
<h2 id="optional-maintenance">Optional Maintenance<a class="headerlink" href="#optional-maintenance" title="Permanent link">&para;</a></h2>
<p>Some tables require additional maintenance. For example, streaming queries may produce small data files that should be <a href="#compact-data-files">compacted into larger files</a>. And some tables can benefit from <a href="#rewrite-manifests">rewriting manifest files</a> to make locating data for queries much faster.</p>
<h3 id="compact-data-files">Compact data files<a class="headerlink" href="#compact-data-files" title="Permanent link">&para;</a></h3>
<p>Iceberg tracks each data file in a table. More data files leads to more metadata stored in manifest files, and small data files causes an unnecessary amount of metadata and less efficient queries from file open costs.</p>
<p>Iceberg can compact data files in parallel using Spark with the <code>rewriteDataFiles</code> action. This will combine small files into larger files to reduce metadata overhead and runtime file open cost.</p>
<pre><code class="language-java">Table table = ...
Actions.forTable(table).rewriteDataFiles()
    .filter(Expressions.equal(&quot;date&quot;, &quot;2020-08-18&quot;))
    .targetSizeInBytes(500 * 1024 * 1024) // 500 MB
    .execute();
</code></pre>
<p>The <code>files</code> metadata table is useful for inspecting data file sizes and determining when to compact partitons.</p>
<p>See the <a href="../javadoc/0.12.0/org/apache/iceberg/actions/RewriteDataFilesAction.html"><code>RewriteDataFilesAction</code> Javadoc</a> to see more configuration options.</p>
<h3 id="rewrite-manifests">Rewrite manifests<a class="headerlink" href="#rewrite-manifests" title="Permanent link">&para;</a></h3>
<p>Iceberg uses metadata in its manifest list and manifest files speed up query planning and to prune unnecessary data files. The metadata tree functions as an index over a table&rsquo;s data.</p>
<p>Manifests in the metadata tree are automatically compacted in the order they are added, which makes queries faster when the write pattern aligns with read filters. For example, writing hourly-partitioned data as it arrives is aligned with time range query filters.</p>
<p>When a table&rsquo;s write pattern doesn&rsquo;t align with the query pattern, metadata can be rewritten to re-group data files into manifests using <code>rewriteManifests</code> or the <code>rewriteManifests</code> action (for parallel rewrites using Spark).</p>
<p>This example rewrites small manifests and groups data files by the first partition field.</p>
<pre><code class="language-java">Table table = ...
table.rewriteManifests()
    .rewriteIf(file -&gt; file.length() &lt; 10 * 1024 * 1024) // 10 MB
    .clusterBy(file -&gt; file.partition().get(0, Integer.class))
    .commit();
</code></pre>
<p>See the <a href="../javadoc/0.12.0/org/apache/iceberg/actions/RewriteManifestsAction.html"><code>RewriteManifestsAction</code> Javadoc</a> to see more configuration options.</p>

  <br>
</div>

<footer class="container-fluid wm-page-content"><p>Copyright 2018-2021 <a href='https://www.apache.org/'>The Apache Software Foundation</a><br />Apache Iceberg, Iceberg, Apache, the Apache feather logo, and the Apache Iceberg project logo are either registered<br />trademarks or trademarks of The Apache Software Foundation in the United States and other countries.</p>
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>