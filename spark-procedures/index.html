<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://iceberg.apache.org/spark-procedures/">
    <link rel="shortcut icon" href="../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Maintenance Procedures - Apache Iceberg</title>
    <link href="../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/highlight.css">
    <link href="../css/extra.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../js/jquery-3.2.1.min.js"></script>
    <script src="../js/bootstrap-3.3.7.min.js"></script>
    <script src="../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Spark Procedures", url: "#_top", children: [
              {title: "Usage", url: "#usage" },
              {title: "Snapshot management", url: "#snapshot-management" },
              {title: "Metadata management", url: "#metadata-management" },
              {title: "Table migration", url: "#table-migration" },
              {title: "Metadata information", url: "#metadata-information" },
          ]},
        ];

    </script>
    <script src="../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    <!--
 - Licensed to the Apache Software Foundation (ASF) under one or more
 - contributor license agreements.  See the NOTICE file distributed with
 - this work for additional information regarding copyright ownership.
 - The ASF licenses this file to You under the Apache License, Version 2.0
 - (the "License"); you may not use this file except in compliance with
 - the License.  You may obtain a copy of the License at
 -
 -   http://www.apache.org/licenses/LICENSE-2.0
 -
 - Unless required by applicable law or agreed to in writing, software
 - distributed under the License is distributed on an "AS IS" BASIS,
 - WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 - See the License for the specific language governing permissions and
 - limitations under the License.
 -->

<h1 id="spark-procedures">Spark Procedures<a class="headerlink" href="#spark-procedures" title="Permanent link">&para;</a></h1>
<p>To use Iceberg in Spark, first configure <a href="../spark-configuration/">Spark catalogs</a>. Stored procedures are only available when using <a href="../spark-configuration/#sql-extensions">Iceberg SQL extensions</a> in Spark 3.x.</p>
<h2 id="usage">Usage<a class="headerlink" href="#usage" title="Permanent link">&para;</a></h2>
<p>Procedures can be used from any configured Iceberg catalog with <code>CALL</code>. All procedures are in the namespace <code>system</code>.</p>
<p><code>CALL</code> supports passing arguments by name (recommended) or by position. Mixing position and named arguments is not supported.</p>
<h3 id="named-arguments">Named arguments<a class="headerlink" href="#named-arguments" title="Permanent link">&para;</a></h3>
<p>All procedure arguments are named. When passing arguments by name, arguments can be in any order and any optional argument can be omitted.</p>
<pre><code class="language-sql">CALL catalog_name.system.procedure_name(arg_name_2 =&gt; arg_2, arg_name_1 =&gt; arg_1)
</code></pre>
<h3 id="positional-arguments">Positional arguments<a class="headerlink" href="#positional-arguments" title="Permanent link">&para;</a></h3>
<p>When passing arguments by position, only the ending arguments may be omitted if they are optional.</p>
<pre><code class="language-sql">CALL catalog_name.system.procedure_name(arg_1, arg_2, ... arg_n)
</code></pre>
<h2 id="snapshot-management">Snapshot management<a class="headerlink" href="#snapshot-management" title="Permanent link">&para;</a></h2>
<h3 id="rollback_to_snapshot"><code>rollback_to_snapshot</code><a class="headerlink" href="#rollback_to_snapshot" title="Permanent link">&para;</a></h3>
<p>Roll back a table to a specific snapshot ID.</p>
<p>To roll back to a specific time, use <a href="#rollback_to_timestamp"><code>rollback_to_timestamp</code></a>.</p>
<p><strong>Note</strong> this procedure invalidates all cached Spark plans that reference the affected table.</p>
<h4 id="usage_1">Usage<a class="headerlink" href="#usage_1" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>Argument Name</th>
<th>Required?</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>table</code></td>
<td>✔️</td>
<td>string</td>
<td>Name of the table to update</td>
</tr>
<tr>
<td><code>snapshot_id</code></td>
<td>✔️</td>
<td>long</td>
<td>Snapshot ID to rollback to</td>
</tr>
</tbody>
</table>
<h4 id="output">Output<a class="headerlink" href="#output" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>Output Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>previous_snapshot_id</code></td>
<td>long</td>
<td>The current snapshot ID before the rollback</td>
</tr>
<tr>
<td><code>current_snapshot_id</code></td>
<td>long</td>
<td>The new current snapshot ID</td>
</tr>
</tbody>
</table>
<h4 id="example">Example<a class="headerlink" href="#example" title="Permanent link">&para;</a></h4>
<p>Roll back table <code>db.sample</code> to snapshot ID <code>1</code>:</p>
<pre><code class="language-sql">CALL catalog_name.system.rollback_to_snapshot('db.sample', 1)
</code></pre>
<h3 id="rollback_to_timestamp"><code>rollback_to_timestamp</code><a class="headerlink" href="#rollback_to_timestamp" title="Permanent link">&para;</a></h3>
<p>Roll back a table to the snapshot that was current at some time.</p>
<p><strong>Note</strong> this procedure invalidates all cached Spark plans that reference the affected table.</p>
<h4 id="usage_2">Usage<a class="headerlink" href="#usage_2" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>Argument Name</th>
<th>Required?</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>table</code></td>
<td>✔️</td>
<td>string</td>
<td>Name of the table to update</td>
</tr>
<tr>
<td><code>timestamp</code></td>
<td>✔️</td>
<td>timestamp</td>
<td>A timestamp to rollback to</td>
</tr>
</tbody>
</table>
<h4 id="output_1">Output<a class="headerlink" href="#output_1" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>Output Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>previous_snapshot_id</code></td>
<td>long</td>
<td>The current snapshot ID before the rollback</td>
</tr>
<tr>
<td><code>current_snapshot_id</code></td>
<td>long</td>
<td>The new current snapshot ID</td>
</tr>
</tbody>
</table>
<h4 id="example_1">Example<a class="headerlink" href="#example_1" title="Permanent link">&para;</a></h4>
<p>Roll back <code>db.sample</code> to a day ago</p>
<pre><code class="language-sql">CALL catalog_name.system.rollback_to_timestamp('db.sample', date_sub(current_date(), 1))
</code></pre>
<h3 id="set_current_snapshot"><code>set_current_snapshot</code><a class="headerlink" href="#set_current_snapshot" title="Permanent link">&para;</a></h3>
<p>Sets the current snapshot ID for a table.</p>
<p>Unlike rollback, the snapshot is not required to be an ancestor of the current table state.</p>
<p><strong>Note</strong> this procedure invalidates all cached Spark plans that reference the affected table.</p>
<h4 id="usage_3">Usage<a class="headerlink" href="#usage_3" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>Argument Name</th>
<th>Required?</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>table</code></td>
<td>✔️</td>
<td>string</td>
<td>Name of the table to update</td>
</tr>
<tr>
<td><code>snapshot_id</code></td>
<td>✔️</td>
<td>long</td>
<td>Snapshot ID to set as current</td>
</tr>
</tbody>
</table>
<h4 id="output_2">Output<a class="headerlink" href="#output_2" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>Output Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>previous_snapshot_id</code></td>
<td>long</td>
<td>The current snapshot ID before the rollback</td>
</tr>
<tr>
<td><code>current_snapshot_id</code></td>
<td>long</td>
<td>The new current snapshot ID</td>
</tr>
</tbody>
</table>
<h4 id="example_2">Example<a class="headerlink" href="#example_2" title="Permanent link">&para;</a></h4>
<p>Set the current snapshot for <code>db.sample</code> to 1:</p>
<pre><code class="language-sql">CALL catalog_name.system.set_current_snapshot('db.sample', 1)
</code></pre>
<h3 id="cherrypick_snapshot"><code>cherrypick_snapshot</code><a class="headerlink" href="#cherrypick_snapshot" title="Permanent link">&para;</a></h3>
<p>Cherry-picks changes from a snapshot into the current table state.</p>
<p>Cherry-picking creates a new snapshot from an existing snapshot without altering or removing the original.</p>
<p>Only append and dynamic overwrite snapshots can be cherry-picked.</p>
<p><strong>Note</strong> this procedure invalidates all cached Spark plans that reference the affected table.</p>
<h4 id="usage_4">Usage<a class="headerlink" href="#usage_4" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>Argument Name</th>
<th>Required?</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>table</code></td>
<td>✔️</td>
<td>string</td>
<td>Name of the table to update</td>
</tr>
<tr>
<td><code>snapshot_id</code></td>
<td>✔️</td>
<td>long</td>
<td>The snapshot ID to cherry-pick</td>
</tr>
</tbody>
</table>
<h4 id="output_3">Output<a class="headerlink" href="#output_3" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>Output Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>source_snapshot_id</code></td>
<td>long</td>
<td>The table&rsquo;s current snapshot before the cherry-pick</td>
</tr>
<tr>
<td><code>current_snapshot_id</code></td>
<td>long</td>
<td>The snapshot ID created by applying the cherry-pick</td>
</tr>
</tbody>
</table>
<h4 id="examples">Examples<a class="headerlink" href="#examples" title="Permanent link">&para;</a></h4>
<p>Cherry-pick snapshot 1</p>
<pre><code class="language-sql">CALL catalog_name.system.cherrypick_snapshot('my_table', 1)
</code></pre>
<p>Cherry-pick snapshot 1 with named args</p>
<pre><code class="language-sql">CALL catalog_name.system.cherrypick_snapshot(snapshot_id =&gt; 1, table =&gt; 'my_table' )
</code></pre>
<h2 id="metadata-management">Metadata management<a class="headerlink" href="#metadata-management" title="Permanent link">&para;</a></h2>
<p>Many <a href="../maintenance/">maintenance actions</a> can be performed using Iceberg stored procedures.</p>
<h3 id="expire_snapshots"><code>expire_snapshots</code><a class="headerlink" href="#expire_snapshots" title="Permanent link">&para;</a></h3>
<p>Each write/update/delete/upsert/compaction in Iceberg produces a new snapshot while keeping the old data and metadata
around for snapshot isolation and time travel. The <code>expire_snapshots</code> procedure can be used to remove older snapshots
and their files which are no longer needed.</p>
<p>This procedure will remove old snapshots and data files which are uniquely required by those old snapshots. This means
the <code>expire_snapshots</code> procedure will never remove files which are still required by a non-expired snapshot.</p>
<h4 id="usage_5">Usage<a class="headerlink" href="#usage_5" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>Argument Name</th>
<th>Required?</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>table</code></td>
<td>✔️</td>
<td>string</td>
<td>Name of the table to update</td>
</tr>
<tr>
<td><code>older_than</code></td>
<td>️</td>
<td>timestamp</td>
<td>Timestamp before which snapshots will be removed (Default: 5 days ago)</td>
</tr>
<tr>
<td><code>retain_last</code></td>
<td></td>
<td>int</td>
<td>Number of ancestor snapshots to preserve regardless of <code>older_than</code> (defaults to 1)</td>
</tr>
</tbody>
</table>
<h4 id="output_4">Output<a class="headerlink" href="#output_4" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>Output Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>deleted_data_files_count</code></td>
<td>long</td>
<td>Number of data files deleted by this operation</td>
</tr>
<tr>
<td><code>deleted_manifest_files_count</code></td>
<td>long</td>
<td>Number of manifest files deleted by this operation</td>
</tr>
<tr>
<td><code>deleted_manifest_lists_count</code></td>
<td>long</td>
<td>Number of manifest List files deleted by this operation</td>
</tr>
</tbody>
</table>
<h4 id="examples_1">Examples<a class="headerlink" href="#examples_1" title="Permanent link">&para;</a></h4>
<p>Remove snapshots older than 10 days ago, but retain the last 100 snapshots:</p>
<pre><code class="language-sql">CALL hive_prod.system.expire_snapshots('db.sample', date_sub(current_date(), 10), 100)
</code></pre>
<p>Erase all snapshots older than the current timestamp but retain the last 5 snapshots:</p>
<pre><code class="language-sql">CALL hive_prod.system.expire_snapshots(table =&gt; 'db.sample', older_than =&gt; now(), retain_last =&gt; 5)
</code></pre>
<h3 id="remove_orphan_files"><code>remove_orphan_files</code><a class="headerlink" href="#remove_orphan_files" title="Permanent link">&para;</a></h3>
<p>Used to remove files which are not referenced in any metadata files of an Iceberg table and can thus be considered &ldquo;orphaned&rdquo;.</p>
<h4 id="usage_6">Usage<a class="headerlink" href="#usage_6" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>Argument Name</th>
<th>Required?</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>table</code></td>
<td>✔️</td>
<td>string</td>
<td>Name of the table to clean</td>
</tr>
<tr>
<td><code>older_than</code></td>
<td>️</td>
<td>timestamp</td>
<td>Remove orphan files created before this timestamp (Defaults to 3 days ago)</td>
</tr>
<tr>
<td><code>location</code></td>
<td></td>
<td>string</td>
<td>Directory to look for files in (defaults to the table&rsquo;s location)</td>
</tr>
<tr>
<td><code>dry_run</code></td>
<td></td>
<td>boolean</td>
<td>When true, don&rsquo;t actually remove files (defaults to false)</td>
</tr>
</tbody>
</table>
<h4 id="output_5">Output<a class="headerlink" href="#output_5" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>Output Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>orphan_file_location</code></td>
<td>String</td>
<td>The path to each file determined to be an orphan by this command</td>
</tr>
</tbody>
</table>
<h4 id="examples_2">Examples<a class="headerlink" href="#examples_2" title="Permanent link">&para;</a></h4>
<p>List all the files that are candidates for removal by performing a dry run of the <code>remove_orphan_files</code> command on this table without actually removing them:</p>
<pre><code class="language-sql">CALL catalog_name.system.remove_orphan_files(table =&gt; 'db.sample', dry_run =&gt; true)
</code></pre>
<p>Remove any files in the <code>tablelocation/data</code> folder which are not known to the table <code>db.sample</code>.</p>
<pre><code class="language-sql">CALL catalog_name.system.remove_orphan_files(table =&gt; 'db.sample', location =&gt; 'tablelocation/data')
</code></pre>
<h3 id="rewrite_manifests"><code>rewrite_manifests</code><a class="headerlink" href="#rewrite_manifests" title="Permanent link">&para;</a></h3>
<p>Rewrite manifests for a table to optimize scan planning.</p>
<p>Data files in manifests are sorted by fields in the partition spec. This procedure runs in parallel using a Spark job.</p>
<p>See the <a href="../javadoc/0.12.0/org/apache/iceberg/actions/RewriteManifestsAction.html"><code>RewriteManifestsAction</code> Javadoc</a>
to see more configuration options.</p>
<p><strong>Note</strong> this procedure invalidates all cached Spark plans that reference the affected table.</p>
<h4 id="usage_7">Usage<a class="headerlink" href="#usage_7" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>Argument Name</th>
<th>Required?</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>table</code></td>
<td>✔️</td>
<td>string</td>
<td>Name of the table to update</td>
</tr>
<tr>
<td><code>use_caching</code></td>
<td>️</td>
<td>boolean</td>
<td>Use Spark caching during operation (defaults to true)</td>
</tr>
</tbody>
</table>
<h4 id="output_6">Output<a class="headerlink" href="#output_6" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>Output Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>rewritten_manifests_count</code></td>
<td>int</td>
<td>Number of manifests which were re-written by this command</td>
</tr>
<tr>
<td><code>added_mainfests_count</code></td>
<td>int</td>
<td>Number of new manifest files which were written by this command</td>
</tr>
</tbody>
</table>
<h4 id="examples_3">Examples<a class="headerlink" href="#examples_3" title="Permanent link">&para;</a></h4>
<p>Rewrite the manifests in table <code>db.sample</code> and align manifest files with table partitioning.</p>
<pre><code class="language-sql">CALL catalog_name.system.rewrite_manifests('db.sample')
</code></pre>
<p>Rewrite the manifests in table <code>db.sample</code> and disable the use of Spark caching. This could be done to avoid memory issues on executors.</p>
<pre><code class="language-sql">CALL catalog_name.system.rewrite_manifests('db.sample', false)
</code></pre>
<h2 id="table-migration">Table migration<a class="headerlink" href="#table-migration" title="Permanent link">&para;</a></h2>
<p>The <code>snapshot</code> and <code>migrate</code> procedures help test and migrate existing Hive or Spark tables to Iceberg.</p>
<h3 id="snapshot"><code>snapshot</code><a class="headerlink" href="#snapshot" title="Permanent link">&para;</a></h3>
<p>Create a light-weight temporary copy of a table for testing, without changing the source table.</p>
<p>The newly created table can be changed or written to without affecting the source table, but the snapshot uses the original table&rsquo;s data files.</p>
<p>When inserts or overwrites run on the snapshot, new files are placed in the snapshot table&rsquo;s location rather than the original table location.</p>
<p>When finished testing a snapshot table, clean it up by running <code>DROP TABLE</code>.</p>
<p><strong>Note</strong> Because tables created by <code>snapshot</code> are not the sole owners of their data files, they are prohibited from
actions like <code>expire_snapshots</code> which would physically delete data files. Iceberg deletes, which only effect metadata,
are still allowed. In addition, any operations which affect the original data files will disrupt the Snapshot&rsquo;s 
integrity. DELETE statements executed against the original Hive table will remove original data files and the
<code>snapshot</code> table will no longer be able to access them.</p>
<p>See <a href="#migrate-table-procedure"><code>migrate</code></a> to replace an existing table with an Iceberg table.</p>
<h4 id="usage_8">Usage<a class="headerlink" href="#usage_8" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>Argument Name</th>
<th>Required?</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>source_table</code></td>
<td>✔️</td>
<td>string</td>
<td>Name of the table to snapshot</td>
</tr>
<tr>
<td><code>table</code></td>
<td>✔️</td>
<td>string</td>
<td>Name of the new Iceberg table to create</td>
</tr>
<tr>
<td><code>location</code></td>
<td></td>
<td>string</td>
<td>Table location for the new table (delegated to the catalog by default)</td>
</tr>
<tr>
<td><code>properties</code></td>
<td>️</td>
<td>map<string, string></td>
<td>Properties to add to the newly created table</td>
</tr>
</tbody>
</table>
<h4 id="output_7">Output<a class="headerlink" href="#output_7" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>Output Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>imported_files_count</code></td>
<td>long</td>
<td>Number of files added to the new table</td>
</tr>
</tbody>
</table>
<h4 id="examples_4">Examples<a class="headerlink" href="#examples_4" title="Permanent link">&para;</a></h4>
<p>Make an isolated Iceberg table which references table <code>db.sample</code> named <code>db.snap</code> at the
catalog&rsquo;s default location for <code>db.snap</code>.</p>
<pre><code class="language-sql">CALL catalog_name.system.snapshot('db.sample', 'db.snap')
</code></pre>
<p>Migrate an isolated Iceberg table which references table <code>db.sample</code> named <code>db.snap</code> at
a manually specified location <code>/tmp/temptable/</code>.</p>
<pre><code class="language-sql">CALL catalog_name.system.snapshot('db.sample', 'db.snap', '/tmp/temptable/')
</code></pre>
<h3 id="migrate"><code>migrate</code><a class="headerlink" href="#migrate" title="Permanent link">&para;</a></h3>
<p>Replace a table with an Iceberg table, loaded with the source&rsquo;s data files.</p>
<p>Table schema, partitioning, properties, and location will be copied from the source table.</p>
<p>Migrate will fail if any table partition uses an unsupported format. Supported formats are Avro, Parquet, and ORC.
Existing data files are added to the Iceberg table&rsquo;s metadata and can be read using a name-to-id mapping created from the original table schema.</p>
<p>To leave the original table intact while testing, use <a href="#snapshot"><code>snapshot</code></a> to create new temporary table that shares source data files and schema.</p>
<h4 id="usage_9">Usage<a class="headerlink" href="#usage_9" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>Argument Name</th>
<th>Required?</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>table</code></td>
<td>✔️</td>
<td>string</td>
<td>Name of the table to migrate</td>
</tr>
<tr>
<td><code>properties</code></td>
<td>️</td>
<td>map<string, string></td>
<td>Properties for the new Iceberg table</td>
</tr>
</tbody>
</table>
<h4 id="output_8">Output<a class="headerlink" href="#output_8" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>Output Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>migrated_files_count</code></td>
<td>long</td>
<td>Number of files appended to the Iceberg table</td>
</tr>
</tbody>
</table>
<h4 id="examples_5">Examples<a class="headerlink" href="#examples_5" title="Permanent link">&para;</a></h4>
<p>Migrate the table <code>db.sample</code> in Spark&rsquo;s default catalog to an Iceberg table and add a property &lsquo;foo&rsquo; set to &lsquo;bar&rsquo;:</p>
<pre><code class="language-sql">CALL catalog_name.system.migrate('spark_catalog.db.sample', map('foo', 'bar'))
</code></pre>
<p>Migrate <code>db.sample</code> in the current catalog to an Iceberg table without adding any additional properties:</p>
<pre><code class="language-sql">CALL catalog_name.system.migrate('db.sample')
</code></pre>
<h3 id="add_files"><code>add_files</code><a class="headerlink" href="#add_files" title="Permanent link">&para;</a></h3>
<p>Attempts to directly add files from a Hive or file based table into a given Iceberg table. Unlike migrate or
snapshot, <code>add_files</code> can import files from a specific partition or partitions and does not create a new Iceberg table.
This command will create metadata for the new files and will not move them. This procedure will not analyze the schema 
of the files to determine if they actually match the schema of the Iceberg table. Upon completion, the Iceberg table 
will then treat these files as if they are part of the set of files  owned by Iceberg. This means any subsequent 
<code>expire_snapshot</code> calls will be able to physically delete the added files. This method should not be used if 
<code>migrate</code> or <code>snapshot</code> are possible.</p>
<h4 id="usage_10">Usage<a class="headerlink" href="#usage_10" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>Argument Name</th>
<th>Required?</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>table</code></td>
<td>✔️</td>
<td>string</td>
<td>Table which will have files added to</td>
</tr>
<tr>
<td><code>source_table</code></td>
<td>✔️</td>
<td>string</td>
<td>Table where files should come from, paths are also possible in the form of `file_format`.`path`</td>
</tr>
<tr>
<td><code>partition_filter</code></td>
<td>️</td>
<td>map<string, string></td>
<td>A map of partitions in the source table to import from</td>
</tr>
</tbody>
</table>
<p>Warning : Schema is not validated, adding files with different schema to the Iceberg table will cause issues.</p>
<p>Warning : Files added by this method can be physically deleted by Iceberg operations</p>
<h4 id="examples_6">Examples<a class="headerlink" href="#examples_6" title="Permanent link">&para;</a></h4>
<p>Add the files from table <code>db.src_table</code>, a Hive or Spark table registered in the session Catalog, to Iceberg table
<code>db.tbl</code>. Only add files that exist within partitions where <code>part_col_1</code> is equal to <code>A</code>.</p>
<pre><code class="language-sql">CALL spark_catalog.system.add_files(
table =&gt; 'db.tbl',
source_table =&gt; 'db.src_tbl',
partition_filter =&gt; map('part_col_1', 'A')
)
</code></pre>
<p>Add files from a <code>parquet</code> file based table at location <code>path/to/table</code> to the Iceberg table <code>db.tbl</code>. Add all
files regardless of what partition they belong to.</p>
<pre><code class="language-sql">CALL spark_catalog.system.add_files(
  table =&gt; 'db.tbl',
  source_table =&gt; '`parquet`.`path/to/table`'
)
</code></pre>
<h2 id="metadata-information"><code>Metadata information</code><a class="headerlink" href="#metadata-information" title="Permanent link">&para;</a></h2>
<h3 id="ancestors_of"><code>ancestors_of</code><a class="headerlink" href="#ancestors_of" title="Permanent link">&para;</a></h3>
<p>Report the live snapshot IDs of parents of a specified snapshot</p>
<h4 id="usage_11">Usage<a class="headerlink" href="#usage_11" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>Argument Name</th>
<th>Required?</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>table</code></td>
<td>✔️</td>
<td>string</td>
<td>Name of the table to report live snapshot IDs</td>
</tr>
<tr>
<td><code>snapshot_id</code></td>
<td>️</td>
<td>long</td>
<td>Use a specified snapshot to get the live snapshot IDs of parents</td>
</tr>
</tbody>
</table>
<blockquote>
<p>tip : Using snapshot_id</p>
<p>Given snapshots history with roll back to B and addition of C&rsquo; -&gt; D&rsquo;
<code>shell
A -&gt; B - &gt; C -&gt; D
      \ -&gt; C' -&gt; (D')</code>
Not specifying the snapshot ID would return A -&gt; B -&gt; C&rsquo; -&gt; D&rsquo;, while providing the snapshot ID of
D as an argument would return A-&gt; B -&gt; C -&gt; D</p>
</blockquote>
<h4 id="output_9">Output<a class="headerlink" href="#output_9" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>Output Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>snapshot_id</code></td>
<td>long</td>
<td>the ancestor snapshot id</td>
</tr>
<tr>
<td><code>timestamp</code></td>
<td>long</td>
<td>snapshot creation time</td>
</tr>
</tbody>
</table>
<h4 id="examples_7">Examples<a class="headerlink" href="#examples_7" title="Permanent link">&para;</a></h4>
<p>Get all the snapshot ancestors of current snapshots(default)</p>
<pre><code class="language-sql">CALL spark_catalog.system.ancestors_of('db.tbl')
</code></pre>
<p>Get all the snapshot ancestors by a particular snapshot</p>
<pre><code class="language-sql">CALL spark_catalog.system.ancestors_of('db.tbl', 1)
CALL spark_catalog.system.ancestors_of(snapshot_id =&gt; 1, table =&gt; 'db.tbl')
</code></pre>

  <br>
</div>

<footer class="container-fluid wm-page-content"><p>Copyright 2018-2021 <a href='https://www.apache.org/'>The Apache Software Foundation</a><br />Apache Iceberg, Iceberg, Apache, the Apache feather logo, and the Apache Iceberg project logo are either registered<br />trademarks or trademarks of The Apache Software Foundation in the United States and other countries.</p>
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>